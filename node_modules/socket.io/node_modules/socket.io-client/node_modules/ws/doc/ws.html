<h1 id="ws">ws</h1>
<h2 id="class-ws-server">Class: ws.Server</h2>
<p>This class is a WebSocket server. It is an <code>EventEmitter</code>.</p>
<h3 id="new-ws-server-options-callback-">new ws.Server([options], [callback])</h3>
<ul>
<li><code>options</code> Object<ul>
<li><code>host</code> String</li>
<li><code>port</code> Number</li>
<li><code>server</code> http.Server</li>
<li><code>verifyClient</code> Function</li>
<li><code>path</code> String</li>
<li><code>noServer</code> Boolean</li>
<li><code>disableHixie</code> Boolean</li>
<li><code>clientTracking</code> Boolean</li>
</ul>
</li>
<li><code>callback</code> Function</li>
</ul>
<p>Construct a new server object.</p>
<p>Either <code>port</code> or <code>server</code> must be provided, otherwise you might enable
<code>noServer</code> if you want to pass the requests directly. Please note that the
<code>callback</code> is only used when you supply the a <code>port</code> number in the options.</p>
<h3 id="server-close-code-data-">server.close([code], [data])</h3>
<p>Close the server and terminate all clients</p>
<h3 id="server-handleupgrade-request-socket-upgradehead-callback-">server.handleUpgrade(request, socket, upgradeHead, callback)</h3>
<p>Handles a HTTP Upgrade request. <code>request</code> is an instance of <code>http.ServerRequest</code>, <code>socket</code> is an instance of <code>net.Socket</code>.</p>
<p>When the Upgrade was successfully, the <code>callback</code> will be called with a <code>ws.WebSocket</code> object as parameter.</p>
<h3 id="event-error-">Event: &#39;error&#39;</h3>
<p><code>function (error) { }</code></p>
<p>If the underlying server emits an error, it will be forwarded here.</p>
<h3 id="event-headers-">Event: &#39;headers&#39;</h3>
<p><code>function (headers) { }</code></p>
<p>Emitted with the object of HTTP headers that are going to be written to the <code>Stream</code> as part of the handshake.</p>
<h3 id="event-connection-">Event: &#39;connection&#39;</h3>
<p><code>function (socket) { }</code></p>
<p>When a new WebSocket connection is established. <code>socket</code> is an object of type <code>ws.WebSocket</code>.</p>
<h2 id="class-ws-websocket">Class: ws.WebSocket</h2>
<p>This class represents a WebSocket connection. It is an <code>EventEmitter</code>.</p>
<h3 id="new-ws-websocket-address-options-">new ws.WebSocket(address, [options])</h3>
<ul>
<li><code>address</code> String|Array</li>
<li><code>options</code> Object<ul>
<li><code>protocol</code> String</li>
<li><code>agent</code> Agent</li>
<li><code>headers</code> Object</li>
<li><code>protocolVersion</code> Number|String<br>-- the following only apply if <code>address</code> is a String</li>
<li><code>host</code> String</li>
<li><code>origin</code> String</li>
<li><code>pfx</code> String|Buffer</li>
<li><code>key</code> String|Buffer</li>
<li><code>passphrase</code> String</li>
<li><code>cert</code> String|Buffer</li>
<li><code>ca</code> Array</li>
<li><code>ciphers</code> String</li>
<li><code>rejectUnauthorized</code> Boolean</li>
</ul>
</li>
</ul>
<p>Instantiating with an <code>address</code> creates a new WebSocket client object. If <code>address</code> is an Array (request, socket, rest), it is instantiated as a Server client (e.g. called from the <code>ws.Server</code>).</p>
<h3 id="websocket-bytesreceived">websocket.bytesReceived</h3>
<p>Received bytes count.</p>
<h3 id="websocket-readystate">websocket.readyState</h3>
<p>Possible states are <code>WebSocket.CONNECTING</code>, <code>WebSocket.OPEN</code>, <code>WebSocket.CLOSING</code>, <code>WebSocket.CLOSED</code>.</p>
<h3 id="websocket-protocolversion">websocket.protocolVersion</h3>
<p>The WebSocket protocol version used for this connection, <code>8</code>, <code>13</code> or <code>hixie-76</code> (the latter only for server clients).</p>
<h3 id="websocket-url">websocket.url</h3>
<p>The URL of the WebSocket server (only for clients)</p>
<h3 id="websocket-supports">websocket.supports</h3>
<p>Describes the feature of the used protocol version. E.g. <code>supports.binary</code> is a boolean that describes if the connection supports binary messages.</p>
<h3 id="websocket-close-code-data-">websocket.close([code], [data])</h3>
<p>Gracefully closes the connection, after sending a description message</p>
<h3 id="websocket-pause-">websocket.pause()</h3>
<p>Pause the client stream</p>
<h3 id="websocket-ping-data-options-dontfailwhenclosed-">websocket.ping([data], [options], [dontFailWhenClosed])</h3>
<p>Sends a ping. <code>data</code> is sent, <code>options</code> is an object with members <code>mask</code> and <code>binary</code>. <code>dontFailWhenClosed</code> indicates whether or not to throw if the connection isnt open.</p>
<h3 id="websocket-pong-data-options-dontfailwhenclosed-">websocket.pong([data], [options], [dontFailWhenClosed])</h3>
<p>Sends a pong. <code>data</code> is sent, <code>options</code> is an object with members <code>mask</code> and <code>binary</code>. <code>dontFailWhenClosed</code> indicates whether or not to throw if the connection isnt open.</p>
<h3 id="websocket-resume-">websocket.resume()</h3>
<p>Resume the client stream</p>
<h3 id="websocket-send-data-options-callback-">websocket.send(data, [options], [callback])</h3>
<p>Sends <code>data</code> through the connection. <code>options</code> can be an object with members <code>mask</code> and <code>binary</code>. The optional <code>callback</code> is executed after the send completes.</p>
<h3 id="websocket-stream-options-callback-">websocket.stream([options], callback)</h3>
<p>Streams data through calls to a user supplied function. <code>options</code> can be an object with members <code>mask</code> and <code>binary</code>.  <code>callback</code> is executed on successive ticks of which send is <code>function (data, final)</code>.</p>
<h3 id="websocket-terminate-">websocket.terminate()</h3>
<p>Immediately shuts down the connection</p>
<h3 id="websocket-onopen">websocket.onopen</h3>
<h3 id="websocket-onerror">websocket.onerror</h3>
<h3 id="websocket-onclose">websocket.onclose</h3>
<h3 id="websocket-onmessage">websocket.onmessage</h3>
<p>Emulates the W3C Browser based WebSocket interface using function members.</p>
<h3 id="websocket-addeventlistener-method-listener-">websocket.addEventListener(method, listener)</h3>
<p>Emulates the W3C Browser based WebSocket interface using addEventListener.</p>
<h3 id="event-error-">Event: &#39;error&#39;</h3>
<p><code>function (error) { }</code></p>
<p>If the client emits an error, this event is emitted (errors from the underlying <code>net.Socket</code> are forwarded here).</p>
<h3 id="event-close-">Event: &#39;close&#39;</h3>
<p><code>function (code, message) { }</code></p>
<p>Is emitted when the connection is closed. <code>code</code> is defined in the WebSocket specification.</p>
<p>The <code>close</code> event is also emitted when then underlying <code>net.Socket</code> closes the connection (<code>end</code> or <code>close</code>).</p>
<h3 id="event-message-">Event: &#39;message&#39;</h3>
<p><code>function (data, flags) { }</code></p>
<p>Is emitted when data is received. <code>flags</code> is an object with member <code>binary</code>.</p>
<h3 id="event-ping-">Event: &#39;ping&#39;</h3>
<p><code>function (data, flags) { }</code></p>
<p>Is emitted when a ping is received. <code>flags</code> is an object with member <code>binary</code>.</p>
<h3 id="event-pong-">Event: &#39;pong&#39;</h3>
<p><code>function (data, flags) { }</code></p>
<p>Is emitted when a pong is received. <code>flags</code> is an object with member <code>binary</code>.</p>
<h3 id="event-open-">Event: &#39;open&#39;</h3>
<p><code>function () { }</code></p>
<p>Emitted when the connection is established.</p>
